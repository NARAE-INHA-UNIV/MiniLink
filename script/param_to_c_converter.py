"""param_to_c_converter.py

XML 형식으로 정의된 C 구조체 레이아웃을 실제 C 헤더 파일(.h)로 자동 변환합니다.

이 스크립트는 중첩된 구조체(nested structs), 배열(예: 'name[16]'),
비트 필드(예: 'bit="1"')를 포함한 복잡한 구조를 파싱할 수 있습니다.
생성되는 모든 구조체에는 '__attribute__((packed))' 속성이 자동으로 추가되며,
헤더 가드(#ifndef ... #endif)도 생성됩니다.

사용법:
    python param_to_c_converter.py <입력_XML_파일.xml>

Created on: Sep 04, 2025
Author: Gemini 2.5 Pro, leecurrent04
Email: leecurrent04@inha.edu
"""

__version__ = "0.1.0"

import xml.etree.ElementTree as ET
import re
import os
import sys

def parse_name_and_array(name_str):
    """'name[size]' 형식의 문자열을 파싱하여 이름과 배열 부분을 분리합니다."""
    if not name_str:
        return 'anonymous_struct', ''
    match = re.match(r"([\w_]+)(\[\s*\d*\s*\])?", name_str)
    if match:
        name = match.group(1)
        array_suffix = match.group(2) if match.group(2) else ""
        return name, array_suffix
    return name_str, ""

def generate_c_from_element(element, indent_level=0):
    """
    하나의 XML 엘리먼트(struct 또는 typedef)를 C 코드 조각으로 변환합니다.
    재귀적으로 호출되어 중첩 구조를 처리합니다.
    """
    is_typedef = element.tag == 'typedef'
    
    current_indent = "    " * indent_level
    member_indent = "    " * (indent_level + 1)
    
    name_str = element.attrib.get('name', '')
    var_name, array_suffix = parse_name_and_array(name_str)
    
    # <description> 태그의 내용을 주석으로 추가
    description_element = element.find('description')
    description_text = description_element.text.strip() if description_element is not None and description_element.text else ""
    description_comment = f"{current_indent}// {description_text}" if description_text else ""

    # 구조체 멤버(필드)들을 저장할 리스트
    members = []
    
    # 현재 엘리먼트의 자식들을 순회하며 멤버 코드 생성
    for child in element:
        if child.tag in ('field', 'enum'):
            # field와 enum은 모두 변수 선언으로 처리
            field_type = child.attrib.get('type', 'void')
            field_name = child.attrib.get('name', 'unknown_field')
            
            # bit 속성이 있으면 비트 필드로 처리
            bit_value = child.attrib.get('bit')
            bitfield_suffix = f" : {bit_value}" if bit_value else ""
            
            members.append(f"{member_indent}{field_type} {field_name}{bitfield_suffix};")
            
        elif child.attrib.get('type'):
            # struct라도 type이 있으면 type으로 처리
            field_type = child.attrib.get('type', 'void')
            field_name = child.attrib.get('name', 'unknown_field')
            members.append(f"{member_indent}{field_type} {field_name};")

        elif child.tag == 'struct':
            # 자식 struct에 대해 재귀적으로 C 코드 생성
            nested_struct_code = generate_c_from_element(child, indent_level + 1)
            members.append(nested_struct_code)
            
    members_str = "\n".join(members)

    # 최종 C 코드 형식 조합
    if is_typedef:
        # 최상위 typedef struct ... NAME;
        code = (
            f"typedef struct __attribute__((packed)) {{\n"
            f"{members_str}\n"
            f"}} {var_name};"
        )
        return f"{description_comment}\n{code}" if description_comment else code
    else:
        # 중첩된 struct { ... } name[size];
        code = (
            f"{current_indent}struct __attribute__((packed)) {{\n"
            f"{members_str}\n"
            f"{current_indent}}} {var_name}{array_suffix};"
        )
        return f"{description_comment}\n{code}" if description_comment else code

def convert_xml_to_c_header(xml_path, h_path):
    """XML 파일을 C 헤더 파일로 변환하는 메인 함수"""
    try:
        tree = ET.parse(xml_path)
        root = tree.getroot()

        typedef_root = root.find('typedef')
        if typedef_root is None:
            print("오류: XML 파일에서 <typedef> 루트 태그를 찾을 수 없습니다.")
            return

        guard_name = os.path.basename(h_path).upper().replace('.', '_') + '_'

        xml_version = root.find('version').text
        converter_version = __version__

        # 2. C언어 헤더 주석 블록을 f-string으로 생성합니다.
        header_comment = f"""/*
 * =================================================================================
 * AUTO-GENERATED FILE. DO NOT EDIT.
 * =================================================================================
 *
 * This file was automatically generated by the param_to_c_converter.py script.
 * Any changes made to this file will be overwritten on the next run.
 *
 * Source XML Version: {xml_version}
 * Converter Version: {converter_version}
 *
 */\n
 """

        # 3. 최종 헤더 부분을 조립합니다.
        c_code_parts = [
            header_comment,
            f"#ifndef {guard_name}",
            f"#define {guard_name}\n",
            f"\n#define _MINILINK_PARAM_XML_VERSION    ({xml_version})\n",
            '#include <stdint.h> // For uint8_t, uint16_t, etc.\n'
        ]

        c_struct_code = generate_c_from_element(typedef_root, indent_level=0)
        c_code_parts.append(c_struct_code)
        
        c_code_parts.append(f"\n#endif // {guard_name}")

        final_c_code = "\n".join(c_code_parts)
        with open(h_path, 'w', encoding='utf-8') as f:
            f.write(final_c_code)
            
        print(f"✅ 성공! '{xml_path}' -> '{h_path}' 변환 완료.")

    except ET.ParseError as e:
        print(f"오류: XML 파일을 파싱할 수 없습니다. ({e})")
    except FileNotFoundError:
        print(f"오류: 입력 파일 '{xml_path}'를 찾을 수 없습니다.")
    except Exception as e:
        print(f"알 수 없는 오류가 발생했습니다: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("사용법: python xml_to_c_converter.py <입력_XML_파일.xml>")
    else:
        input_xml_file = sys.argv[1]
        output_h_file = os.path.splitext(input_xml_file)[0] + ".h"
        convert_xml_to_c_header(input_xml_file, output_h_file)